# 获取号码功能

域名只会访问主的，两个redis，所以永远只会访问主的redis，除非切换到备机房

## V1版本

从数据库根据号码排序获取，获取完了，就重头开始获取，获取的号码都放到redis，每次获取时都去除redis的号码

由于号码可能在不同国家相同，获取接口使用国家维度的锁，防止被不同用户重复获取

## v2版本

### 几个用到的redis key解释

**待售list**；类型:list；存储每个国家的号码

```
number:{country}
```

**锁定号码String**；类型:String；用户从待售list获取号码后，存下来10分钟；value是用户id（什么都行）

```
lock-get-number:{number}
```

**锁定号码hash**；类型:hash；用户从待售list获取号码后，存下来；用于获取后不购买，要恢复到**待售list**；**key**是**号码**，value是国家

```
lock-get-number-hash
```

### 几个方法解释

#### 获取号码

从**待售list**取下来，分别存到**锁定号码String**，**锁定号码hash**

#### 提交订单

1. 根据传过来号码列表，生成订单信息，订单里有存号码
2. 成功生成后，删除**锁定号码hash**里对应号码

#### 锁定号码hash 恢复到 待售list 定时任务

1. 获取所有**锁定号码String**，取出号码存到**list**
2. 获取所有**锁定号码hash**，取出号码存到**map**
3. 遍历**map**，找出在**map**，不在**list**的号码
4. **锁定号码hash**删除此号码
5. **待售list**添加此号码

### 会出现的疑问

#### 定时任务作用

1. 用户获取号码后不购买，但是已经从**待售list**删除了，过了10分钟后就要重新加回去
2. 比如获取成功，创建订单缺失败了，这时候**锁定号码hash**还没删除对应号码，就还可以恢复

#### 提交订单和定时任务同时执行，会出现并发问题吗

不会

1. 比如在创建订单成功后要删除**锁定号码hash**里A号码
2. 再删除前，线程突然切换到定时任务，去查找要恢复的号码
3. 这时候会查到A号码，但A号码还在**锁定号码String**，所以不会恢复到**待售list**

极限情况下，获取完最还有零点几秒到期，这时候提交订单，到了第三步线程不在提交订单线程，切换到了定时任务线程，此时可能过期了，定时任务把A号码恢复到**待售list**，同时其他用户获取到提交了订单，就会出现同时购买

**解决办法：**

定时任务获取恢复到**待售list**，延迟执行，这样其他用户就不会获取到，比如延迟10秒，因为不可能切换到其他线程10秒，还没恢复到购买号码线程



redis是单线程不用担心并发，如果获取的数量不满足用户要购买的数量，就放回redis

如果redis宕机了，就请求数据库查询待售的并把待支付订单的号码去掉，放回redis，这样就不会把售卖中的也给加回去，被重复购买

如果获取完了，就没办法像V1版本从头获取

#### 为什么不用set存储，然后pop随机获取呢

因为是双机房，pop没办法保证两个机房的redis随机获取的都是一样的，所以使用list，按顺序存放和获取

## 总结

V1版本获取号码使用了分布式锁，并发有问题，同一时间用户会获取不到号码，由于获取号码会锁定号码10分钟，但是等10分钟后别的用户也可以获取到，第一个用户获取后待在页面不动，10分钟后和第二个用户一起提交，就会重复购买，所以提交订单也加了国家锁，同一国家只能同时有一个用户购买，防止号码被两个用户获取到，然后一起提交订单重复购买

V2版本使用了redis防止并发问题，去锁化，这时候去提交订单也不会有问题，这个号码只被一个用户拥有

# 获取自增编号

把编号存到表里，redis宕机重启后，从数据库里查找最大的那个+1恢复

如果刚开始为空，要先判断数据库有没有值，再去设置自增编号

# 订单创建

先判断号码是否已出售且还被锁定住，判断前后端计算的金额是否一致，订单删除完成还要删除锁定的号码，不让号码重回待售list（定时任务在做重回list），返回订单ID

# 使用延时队列进行取消订单

取消待支付状态的订单，并恢复号码到redis的待售list

# 登录

有手机验证码，邮箱密码，手机号密码登录三种登录方式，点击登录后会返回不带公司id的token，然后出现选择公司的列表，选完后，在调用一个新接口填充公司id到token

# 支付完成，购买号码回调

记录用户和手机号的关系等处理
