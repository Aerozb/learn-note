# 获取号码功能

域名只会访问主的，两个redis，所以永远只会访问主的redis，除非切换到备机房

## V1版本

从数据库根据号码排序获取，获取完了，就重头开始获取，获取的号码都放到redis，每次获取时都去除redis的号码

由于号码可能在不同国家相同，获取接口使用国家维度的锁，防止被不同用户重复获取

## v2版本

1. 新增号码时，将号码存放到redis的待售list

2. 获取号码时放到一个hash里，因为获取的号码如果10分钟内没提交订单需要恢复到待售list，所以临时存到hash，并设置到String中，每个号码10分钟过期
3. 提交订单的时候，会把hash对应号码删除
4. 取消订单，会通过查询订单表的号码，放回list
5. 有个定时任务会找出hash里有，string没有的号码，塞回list。提交订单的时候删除hash里的号码，就不会影响定时任务，因为是遍历hash和string对比，没有的才塞回list，这样并发也不会有问题

redis是单线程不用担心并发，如果获取的数量不满足用户要购买的数量，就放回redis

如果redis宕机了，就请求数据库查询待售的并把待支付订单的号码去掉，放回redis，这样就不会把售卖中的也给加回去，被重复购买

如果获取完了，就没办法像V1版本从头获取

### 为什么不用set存储，然后pop随机获取呢

因为是双机房，pop没办法保证两个机房的redis随机获取的都是一样的，所以使用list，按顺序存放和获取

## 总结

V1版本获取号码使用了分布式锁，并发有问题，同一时间用户会获取不到号码，由于获取号码会锁定号码10分钟，但是等10分钟后别的用户也可以获取到，第一个用户获取后待在页面不动，10分钟后和第二个用户一起提交，就会重复购买，所以提交订单也加了国家锁，同一国家只能同时有一个用户购买，防止号码被两个用户获取到，然后一起提交订单重复购买

V2版本使用了redis防止并发问题，去锁化，这时候去提交订单也不会有问题，这个号码只被一个用户拥有



# 获取自增编号

把编号存到表里，redis宕机重启后，从数据库里查找最大的那个+1恢复

如果刚开始为空，要先判断数据库有没有值，再去设置自增编号

# rocketmq分布式事务

